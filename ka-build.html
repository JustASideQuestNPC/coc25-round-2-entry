<!DOCTYPE html><html>
<!--
CREDITS:
All the code to make p5js work was written by Bluebird and can be found here: https://www.khanacademy.org/computer-programming/p5js-on-ka/5684432689086464
-->
<head>
    <title>CoC Entry 2 WIP KA Build</title>
    <style>
        body{
            margin:0;
            overflow:hidden;
        }
    </style>
    <!-- Do not touch these scripts!! -->
    <!-- Pull down the file for p5js so we can use it -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.3/lib/p5.min.js"></script>
    <!-- Activate "on-demand global mode", which allows us to use createVector() and other
         p5-specific functions outside of setup() and draw(). -->
    <script>new p5();</script>
    <!-- Define a loop protector that does nothing - even though this doesn't do anything, it has to
         be defined if we want to spread things across multiple script elements (we do). -->
    <script type>var KAInfiniteLoopProtect = () => {};</script>

<!-- Project code starts here. -->

<!-- src/_CONFIGS.js -->
<script type>
// SO MANY CONFIG VARIABLES
// Note: When measuring distance, a "unit" is equal to one pixel when the camera is not zoomed in or
// out. The camera is zoomed out a little here because the sprites are pretty big, so a unit is
// between 1/2 and 3/4 of a pixel depending on what I have the zoom set to right now.

/**
 * How long press-type inputs are considered "pressed" for, in seconds. This allows an action to be
 * performed even if the key for it is pressed a bit too early (for example, pressing the jump key
 * just before you hit the ground will still make you jump after you hit the ground). This can make
 * controls feel much better, assuming your code is set up to correctly use the buffer.
 * @type {number}
 */
// note: attaching a variable to "globalThis" allows it to be accessible in other files
globalThis.INPUT_BUFFER_DURATION = 0.15;

/**
 * Keybinds for all inputs.
 * @type {Object<string, string[]>}
 */
globalThis.KEYBINDS = {
    "move up": ["w", "ArrowUp"],
    "move down": ["s", "ArrowDown"],
    "move left": ["a", "ArrowLeft"],
    "move right": ["d", "ArrowRight"],
    "shoot": ["left mouse"]
};

/**
 * Configs for all weapons, organized by category and name.
 * @type {Object<string, Object[]>}
 */
globalThis.WEAPONS = {
    "pistols": [
        // starter gun
        {
            displayName: "Peashooter", // name shown in the ui
            description: "Doesn't actually shoot peas.", // description shown in the ui
            weaponType: "hitscan",
            fireMode: "full", // "semi" or "full"
            fireRate: 450, // rounds per minute
            burstRate: -1, // rounds per minute
            shotsPerBurst: 1,
            bulletsPerShot: 1,
            minSpread: 0, // degrees
            maxSpread: 10, // degrees
            spreadBloom: 2, // degrees
            spreadRecovery: 5, // degrees per second
            maxRange: 750, // units
        }
    ],
    "autoRifles": [],
    "sniperRifles": [],
    "explosives": []
};
</script>
<!-- src/assets/sprite-class.js -->
<script type>
/**
 * @typedef {Object} SpriteData
 * @property {number} width
 * @property {number} height
 * @property {[number, number]} origin The point the sprite rotates around, relative to the top left
 *      corner of the image.
 * @property {(Graphics)=>void} draw Function that draws the sprite. The sprite should be translated
 *      so that (0, 0) is at the point it rotates around, and all p5js functions should be called on
 *      the object passed to this function.
 */

/**
 * A pre-rendered image sprite.
 */
 globalThis.Sprite = class {
    /**
     * The pre-rendered image.
     * @type {Graphics}
     */
    #image;

    /**
     * The point the sprite rotates around.
     * @type {[number, number]}
     */
    #origin;

    /**
     * @param {SpriteData} args
     */
    constructor({ width, height, origin, draw: drawSprite }) {
        this.#origin = origin.slice();

        // initialize the image - we're actually using a Graphics object and not an Image object,
        // but the image() function will accept both
        this.#image = createGraphics(width, height);
        // translate to the origin so the image is positioned correctly
        this.#image.push();
        this.#image.translate(origin[0], origin[1]);

        // render the sprite onto the image - this is why we pass an object into this function
        drawSprite(this.#image);

        this.#image.pop();
    }

    /**
     * @overload
     * Draws the sprite to the canvas.
     * @param {number} x
     * @param {number} y
     * @param {number} [angle=0]
     * 
     * @overload
     * Draws the sprite to the canvas.
     * @param {Vector} pos
     * @param {number} [angle=0]
     */
    render(x, y=0, angle=0) {
        // overload to pass x and y as a vector
        if (x instanceof p5.Vector) {
            angle = y;
            y = x.y;
            x = x.x;
        }

        push();
        translate(x, y);
        rotate(angle);

        // offset to account for the origin
        image(this.#image, -this.#origin[0], -this.#origin[1]);

        pop()
    }
};
</script>
<!-- src/assets/sprite-data.js -->
<script type>
/**
 * @typedef {Object} SpriteData
 * @property {number} width
 * @property {number} height
 * @property {[number, number]} origin The point the sprite rotates around, relative to the top left
 *      corner of the image.
 * @property {(Graphics)=>void} draw Function that draws the sprite. The sprite should be translated
 *      so that (0, 0) is at the point it rotates around, and all p5js functions should be called on
 *      the object passed to this function.
 */

/**
 * Data objects used for constructing sprites.
 * @type {Object<string, SpriteData>}
 */
 globalThis.SPRITE_DATA = {
    player: {
        width: 92,
        height: 92,
        origin: [31, 46],
        draw: (g) => {
            // Aligning the rects to the center
            g.rectMode(CENTER);
            
            g.stroke("#304250");
            g.strokeWeight(2);
            g.fill("#96a6bc");
            
            g.circle(0, 30, 30); // His right shoulder
            g.circle(0, -30, 30); // His left shoulder
            
            // His right arm
            g.rect(28, 32, 30, 14);
            
            // His left arm
            g.rect(28, -32, 30, 14);
            
            g.circle(0, 0, 60); // His body
            
            // His Right ear
            g.rect(0, 30, 14, 5);
            
            // His left ear
            g.rect(0, -30, 14, 5);
            
            // Arcs on side of body
            g.noFill();
            g.arc(0, -20, 40, 10, 0, 180); // Left
            g.arc(0, 20, 40, 10, -180, 0); // Right
            
            // Plate line on head
            g.beginShape();
            g.vertex(-23, 17);
            g.bezierVertex(-18, 12, -10, 10, 2, 10);
            g.vertex(10, 0);
            g.vertex(2, -10);
            g.bezierVertex(-10, -10, -18, -12, -23, -17);
            g.endShape();
            
            // Mouth
            g.arc(29, 0, 15, 15, 90, -90);
            
            // Inside of Mouth
            g.fill("#304250");
            g.arc(29, 0, 7, 7, 90, -90);
            
            // Color of eyes
            g.fill("#81ff4d");
            
            // His right eye
            g.push();
                g.translate(13, 12);
                g.rotate(25);
                
                g.rect(0, 0, 8, 14, 0, 1, 5, 1);
            g.pop();
            
            // His left eye
            g.push();
                g.translate(13, -12);
                g.rotate(-25);
                
                g.rect(0, 0, 8, 14, 1, 5, 1, 0);
            g.pop();
            
            // Machine guns on right arm
            g.fill("#d7ebef");
            g.rect(40, 38, 40, 4);
            g.rect(40, 32, 40, 4);
            g.rect(40, 26, 40, 4);
            
            // Machine guns on left arm
            g.fill("#d7ebef");
            g.rect(40, -38, 40, 4);
            g.rect(40, -32, 40, 4);
            g.rect(40, -26, 40, 4);
            
            // Machine gun connecters thingy
            g.fill("#96a6bc");
            
            // Right
            g.rect(28, 32, 8, 20); // Thicker
            g.rect(36, 32, 3, 20); // Thinner
            
            // Left
            g.rect(28, -32, 8, 20); // Thicker
            g.rect(36, -32, 3, 20); // Thinner
            
            // Bolts on right of head
            for (var i = 0; i < 12; i++) {
                g.push();
                    g.translate(0, 30);
                    g.rotate(-67 + i * 12);
                    g.point(0, -15 - sin(-i * 6 * 3) * 5);
                g.pop();
            }
            
            // Bolts on left of head
            for (var i = 0; i < 12; i++) {
                g.push();
                    g.translate(0, -30);
                    g.rotate(113 + i * 12);
                    
                    g.point(0, -15 - sin(-i * 6 * 3) * 5);
                    
                g.pop();
            }
            
            g.strokeWeight(5);
            for (var i = 0; i < 3; i++) {
                g.line(-5 - i * 7, -2 - i * 2, -5 - i * 7, 2 + i * 2);
            }
            
            g.stroke("#3bb9ef");
            g.strokeWeight(3);
            for (var i = 0; i < 3; i++) {
                g.line(-5 - i * 7, -2 - i * 2, -5 - i * 7, 2 + i * 2);
            }
        }
    }
};
</script>
<!-- src/engine/colliders.js -->
<script type>
// this file has classes for 4 different types of collider - point, line, circle, and polygon

/**
 * Internal class for polygon bounding boxes.
 * @class
 */
 class BoundingBox {
    /** @type {number} */
    x;
    /** @type {number} */
    y;
    /** @type {number} */
    w;
    /** @type {number} */
    h;

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     */
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    /**
     * Copies the bounding box.
     * @returns {BoundingBox}
     */
    copy() {
        return new BoundingBox(this.x, this.y, this.w, this.h);
    }

    /**
     * @overload
     * Returns whether the bounding box intersects with another bounding box.
     * @param {BoundingBox} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the bounding box intersects with another bounding box.
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @returns {boolean}
     */
    intersects(x, y, w, h) {
        // overload to pass a bounding box
        if (x instanceof BoundingBox) {
            [x, y, w, h] = [x.x, x.y, x.w, x.h];
        }

        return !(
            x > this.x + this.w || x + w < this.x ||
            y > this.y + this.h || y + h < this.y
        );
    }
}

// these use arrow functions so they're (hopefully) inaccessible outside of this file
/**
 * Returns the smallest axis-aligned bounding box for a polygon - this is the smallest non-rotated
 * rectangle that it will fit inside.
 * @param {Vector[]} points
 * @returns {BoundingBox}
 */
const getBBox = (points) => {
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const point of points) {
        if (point.x < minX) { minX = point.x; }
        if (point.x > maxX) { maxX = point.x; }
        if (point.y < minY) { minY = point.y; }
        if (point.y > maxY) { maxY = point.y; }
    }
    return new BoundingBox(minX, minY, maxX - minX, maxY - minY);
};

/**
 * Returns whether a `PointCollider` is on a `LineCollider`.
 * @param {PointCollider} point
 * @param {LineCollider} line
 * @returns {boolean}
 */
const pointOnLine = (point, line) => {
    const d1 = dist(line.start.x, line.start.y, point.x, point.y);
    const d2 = dist(line.end.x, line.end.y, point.x, point.y);
    return d1 + d2 === dist(line.start.x, line.start.y, line.end.x, line.end.y);
};

/**
 * Returns whether a `PointCollider` is inside of a `CircleCollider`.
 * @param {PointCollider} point
 * @param {CircleCollider} circle
 * @returns {boolean}
 */
const pointInCircle = (point, circle) => {
    const dx = point.x - circle.x;
    const dy = point.y - circle.y;
    return dx * dx + dy * dy < circle.radiusSq;
};

/**
 * Returns whether a `PointCollider` is inside of a `PolygonCollider`.
 * @param {PointCollider} point
 * @param {PolygonCollider} polygon
 * @returns {boolean}
 */
const pointInPolygon = (point, polygon) => {
    // This algorithm is actually extremely simple (at least conceptually, the math is still hard).
    // It creates a really long line extending from the point (the direction doesn't matter), then
    // checks whether that line intersects with each edge of the polygon. If the line intersects
    // with an odd number of edges, the point is inside the polygon. That's it!

    let inside = false;
    const points = polygon.getPoints();

    // mildly evil postfix operator hack
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        const p1 = points[i], p2 = points[j];
        const rayHit = (
            p1.y > point.y !== p2.y > point.y &&
            point.x < ((p2.x - p1.x) * (point.y - p1.y)) / (p2.y - p1.y) + p1.x
        );

        if (rayHit) {
            // rather than incrementing a counter and then checking whether it's an odd number at
            // the end, it's simpler and slightly faster to just toggle a variable back and forth
            inside = !inside;
        }
    }
    return inside;
};

/**
 * Returns whether two `LineColliders` intersect.
 * @param {Vector} pointA
 * @param {Vector} pointB
 * @param {Vector} pointC
 * @param {Vector} pointD
 * @param {Vector} [intersection] If the lines intersect, this will be set to the point where they
 *      intersect. If the lines don't intersect, it will be set to (0, 0).
 * @returns 
 */
const lineIntersection = (pointA, pointB, pointC, pointD, intersection=null) => {
    const z1 = (pointA.x - pointB.x);
    const z2 = (pointC.x - pointD.x);
    const z3 = (pointA.y - pointB.y);
    const z4 = (pointC.y - pointD.y);
    const dist = z1 * z4 - z3 * z2;

    if (dist === 0) {
        if (intersection !== null) { intersection.set(0, 0); }
        return false;
    }

    const tempA = (pointA.x * pointB.y - pointA.y * pointB.x);
    const tempB = (pointC.x * pointD.y - pointC.y * pointD.x);
    const xCoor = (tempA * z2 - z1 * tempB) / dist;
    const yCoor = (tempA * z4 - z3 * tempB) / dist;
  
    const linesIntersect = !(
        xCoor < min(pointA.x, pointB.x) || xCoor > max(pointA.x, pointB.x) ||
        xCoor < min(pointC.x, pointD.x) || xCoor > max(pointC.x, pointD.x) ||
        yCoor < min(pointA.y, pointB.y) || yCoor > max(pointA.y, pointB.y) ||
        yCoor < min(pointC.y, pointD.y) || yCoor > max(pointC.y, pointD.y)
    );

    if (linesIntersect) {
        if (intersection !== null) { intersection.set(xCoor, yCoor); }
        return true;
    }

    if (intersection !== null) { intersection.set(0, 0); }
    return false;
};

/**
 * Returns the closest point on a line to another point.
 * @param {Vector} lineStart
 * @param {Vector} lineEnd
 * @param {Vector} pos
 */
const getClosestPoint = (lineStart, lineEnd, pos) => {
    const atp = p5.Vector.sub(pos, lineStart);
    const atb = p5.Vector.sub(lineEnd, lineStart);
    const t = constrain(p5.Vector.dot(atp, atb) / atb.magSq(), 0, 1);

    return createVector(lineStart.x + atb.x * t, lineStart.y + atb.y * t);
};

/**
 * Returns whether a line crosses a circle.
 * @param {Vector} lineStart 
 * @param {Vector} lineEnd 
 * @param {Vector} circlePos 
 * @param {number} radius 
 * @param {Vector} closest Will be set to the closest point on the line to the center of the circle.
 * @returns {boolean}
 */
const lineInCircle = (lineStart, lineEnd, circlePos, radius, closest) => {
    // find the closest point on the line to the center of the circle, then just check if it's
    // inside the circle
    closest.set(getClosestPoint(lineStart, lineEnd, circlePos));
    return p5.Vector.sub(closest, circlePos).magSq() < sq(radius);
};

/**
 * Returns whether a `LineCollider` intersects with or is inside of a `PolygonCollider`.
 * @param {LineCollider} line
 * @param {PolygonCollider} polygon
 * @returns {boolean}
 */
const lineInPolygon = (line, polygon) => {
    // check whether the line is completely inside the polygon
    if (pointInPolygon(line.start, polygon) || pointInPolygon(line.end, polygon)) {
        return true;
    }
    
    const points = polygon.getPoints();
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        if (lineIntersection(points[i],  points[j], line.start, line.end)) {
            return true;
        }
    }
    return false;
};

/**
 * Determines if two `CircleColliders` intersect.
 * @param {CircleCollider} circle1
 * @param {CircleCollider} circle2
 * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum translation
 *      vector", which is the shortest vector that will move the first circle completely out of the
 *      other one. If there is no collision, it will be set to (0, 0).
 * @returns {boolean}
 */
const circleToCircleCollide = (circle1, circle2, transVec=null) => {
    // difference between circle centers
    const delta = p5.Vector.sub(circle1.position, circle2.position);
    
    if (delta.magSq() < pow(circle1.radius + circle2.radius, 2)) {
        if (transVec) {
            // hehe method chaining go brrrt
            transVec.set(delta.copy().setMag(circle1.radius + circle2.radius).sub(delta));
        }
        return true;
    }
    
    if (transVec !== null) { transVec.set(0, 0); }
    return false;
};

/**
 * Determines if a `PolygonCollider` intersects with a `CircleCollider`.
 * @param {CircleCollider} circle 
 * @param {PolygonCollider} polygon 
 * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum translation
 *      vector", which is the shortest vector that will move the circle completely out of the
 *      polygon. If there is no collision, this will be set to (0, 0).
 * @param {boolean} [invert=false] If true, `transVec` will be set to the shortest vector that moves
 *      the polygon out of the circle, instead of the vector that moves the circle out of the
 *      polygon.
 * @returns {boolean}
 */
const circleToPolygonCollide = (circle, polygon, transVec=null, invert=false) => {
    const circleBBox = new BoundingBox(
        circle.position.x - circle.radius,
        circle.position.y - circle.radius,
        circle.radius * 2,
        circle.radius * 2
    );
    
    if (!circleBBox.intersects(polygon.getBBox())) {
        if (transVec !== null) { transVec.set(0, 0); }
        return false;
    }
    
    // this collision algorithm won't detect a collision if the circle is completely inside the
    // polygon, so we check for that here
    const pos = circle.position.copy();
    if (pointInPolygon(pos, polygon)) {
        let closestPoint = createVector();
        let closestDistance = Infinity;

        const points = polygon.getPoints();
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const p1 = points[i], p2 = points[j];

            const c = getClosestPoint(p1, p2, circle.position);
            if (c.dist(circle.position) < closestDistance) {
                closestDistance = c.dist(circle.position);
                closestPoint.set(c);
            }
        }

        pos.set(closestPoint);
        if (transVec !== null) {
            const delta = p5.Vector.sub(pos, circle.position);
            delta.setMag(delta.mag() + circle.radius);
            if (invert) {
                delta.set(-delta.x, -delta.y);
            }
            transVec.set(delta);
        }
        return true;
    }

    // check if any of the edges on the polygon intersect the ircle, and find the closest
    // intersection point
    let closest = createVector();
    let closestDistance = Infinity;

    const points = polygon.getPoints();
    for (let i = 0, j = points.length - 1; i < points.length; j = i++ ) {
        const p1 = points[i], p2 = points[j];

        // return true if the edge intersects with the circle, and the intersection point is the
        // closest one found
        const p = createVector();
        if (lineInCircle(p1, p2, pos, circle.radius, p)) {
            const d = p.dist(pos);
            if (d < closestDistance) {
                closestDistance = d;
                closest.set(p);
            }
        }
    }

    if (closestDistance < Infinity) {
        // find a translation vector - if invert is true, the vector moves the polygon out of the
        // circle, otherwise it moves the circle out of the polygon
        if (transVec) {
            let delta = p5.Vector.sub(closest, circle.position);
            let moveDistance = circle.radius - delta.mag();
            delta.setMag(-moveDistance);

            if (invert) {
                delta.set(-delta.x, -delta.y);
            }
            transVec.set(delta);
        }
        return true;
    }
    return false;
};

/**
 * Projects a polygon onto an axis and returns the interval it creates on that axis - think of this
 * as squashing the polygon onto a line, then returning the area it covers.
 * @param {PolygonCollider} polygon
 * @param {Vector} axis
 * @returns {[number, number]}
 */
const projectOntoAxis = (polygon, axis) => {
    let min = Infinity;
    let max = -Infinity;

    // find the minimum and maximum points in the projection -
    // these are the two endpoints of the squashed line
    const points = polygon.getPoints()
    for (const p of points) {
        const projection = p.dot(axis);
        if (projection < min) {
            min = projection;
        }
        if (projection > max) {
            max = projection;
        }
    }

    return [min, max];
};

/**
 * Returns the distance/gap between two intervals - if this is < 0, the intervals overlap.
 * @param {[number, number]} i1 
 * @param {[number, number]} i2 
 * @returns {number}
 */
const intervalDistance = (i1, i2) => {
    if (i1[0] < i2[0]) {
        return i2[0] - i1[1];
    }
    else {
        return i1[0] - i2[1];
    }
};

/**
 * Converts the vertices of a polygon into edge vectors; used for SAT collision.
 * @param {PolygonCollider} polygon 
 * @returns {Vector[]}
 */
const getEdges = (polygon) => {
    const edges = [];
    const points = polygon.getPoints();
    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
      edges.push(createVector(points[i].x - points[j].x, points[i].y - points[j].y));
    }
    return edges;
};

/**
 * Determines whether two `PolygonColliders` intersect. This implementation uses the "Separating
 * Axis Theorem", which is really just an overly fancy way of saying "If you can draw a line between
 * two things, they don't overlap."
 * @param {PolygonCollider} poly1
 * @param {PolygonCollider} poly2
 * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum translation
 *      vector", which is the shortest vector that will move the first polygon completely out of the
 *      other one. If there is no collision, it will be set to (0, 0).
 * @returns {boolean}
 */
function polygonToPolygonCollide(poly1, poly2, transVec=null) {
    // SAT is really fast relative to other collision algorithms, but "really fast" is still pretty
    // slow compared to the rest of the program. Bounding box checks are *actually* really fast and
    // will rule out a lot of polygons that definitely don't overlap with this one.
    if (!poly1.getBBox().intersects(poly2.getBBox())) {
        if (transVec !== null) { transVec.set(0, 0); }
      return false;
    }

    // find the edges of both polygons and merge them into a single array
    const poly1Edges = getEdges(poly1);
    const poly2Edges = getEdges(poly2);
    const allEdges = poly1Edges.concat(poly2Edges);

    // used for constructing the MTV (the "minimum translation vector", not the weird tv station)
    let mtvLength = Infinity;
    let mtvAxis = createVector(0, 0);

    // build all axes (axes? axises?) and project both polygons onto them
    for (let i = 0; i < allEdges.length; ++i) {
        const edge = allEdges[i];
        const edgeLength = edge.mag();

        // create an axis that is perpendicular to the edge and normalized
        const axis = createVector(-edge.y / edgeLength, edge.x / edgeLength);

        // project both polygons onto the axis
        const proj1 = projectOntoAxis(poly1, axis);
        const proj2 = projectOntoAxis(poly2, axis);

        // polygons are only overlapping if *all* their rojections overlap, so we can immediately
        // return if we find a projection where they don't overlap (this is why SAT is so fast)
        const overlap = intervalDistance(proj1, proj2);
        if (overlap > 0) {
            return false;
        }
        else {
            // update the MTV if this is the smallest overlap found so far
            if (abs(overlap) < mtvLength) {
                mtvLength = abs(overlap);
                if (proj1[0] < proj2[0]) {
                    mtvAxis.set(-axis.x, -axis.y);
                }
                else {
                    mtvAxis.set(axis.x, axis.y);
                }
            }
        }
    }

    // set transVec to the mtv if it isn't null
    if (transVec !== null) {
      transVec.set(p5.Vector.mult(mtvAxis, mtvLength));
    }
    return true;
}

/**
 * A collider for a single point.
 * @class
 */
globalThis.PointCollider = class {
    /** @type {number} */
    x;
    /** @type {number} */
    y;

    /**
     * @param {number} x
     * @param {number} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    /**
     * @overload
     * Returns whether the point is at the same position as another `PointCollider`.
     * @param {PointCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the point is on a `LineCollider`.
     * @param {LineCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the point is inside a `CircleCollider`.
     * @param {CircleCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the point is inside a `PolygonCollider`.
     * @param {PolygonCollider} other
     * @returns {boolean}
     */
    isColliding(other) {
        if (other instanceof PointCollider) {
            return (this.x === other.x && this.y === other.y);
        }
        else if (other instanceof LineCollider) {
            return pointOnLine(this, other);
        }
        else if (other instanceof CircleCollider) {
            return pointInCircle(this, other);
        }
        else if (other instanceof PolygonCollider) {
            return pointInPolygon(this, other);
        }
        else {
            throw new TypeError(
                `[Collider] Invalid argument to isColliding()! (Expected a PointCollider, ` +
                `LineCollider, CircleCollider, or PolygonCollider; recieved "${typeof other}")`
            );
        }
    }

    /**
     * Draws the collider; useful for debugging.
     * @param {color} color
     */
    render(color) {
        noStroke();
        fill(color);
        circle(this.x, this.y, 6);
    }
};

/**
 * A collider for a straight line.
 * @class
 */
globalThis.LineCollider = class {
    /** @type {Vector} */
    start;

    /** @type {Vector} */
    end;

    /**
     * @overload
     * @param {number} startX
     * @param {number} startY
     * @param {number} endX
     * @param {number} endY
     * 
     * @overload
     * @param {Vector} start
     * @param {Vector} end
     */
    constructor(startX, startY, endX, endY) {
        if (startX instanceof p5.Vector && startY instanceof p5.Vector) {
            this.start = startX.copy();
            this.end = startY.copy();
        }
        else {
            this.start = createVector(startX, startY);
            this.end = createVector(endX, endY);
        }
    }

    /**
     * @overload
     * Returns whether a `PointCollider` is on the line.
     * @param {PointCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the line intersects with another `LineCollider`.
     * @param {LineCollider} other
     * @param {Vector} [intersection] If the lines intersect, this will be set to the point where
     *      they intersect. If the lines don't intersect, it will be set to (0, 0).
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the line crosses or is inside of a `CircleCollider`.
     * @param {CircleCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the line crosses or is inside of a `PolygonCollider`.
     * @param {PolygonCollider} other
     * @returns {boolean}
     */
    isColliding(other, intersection=null) {
        if (other instanceof PointCollider) {
            return pointOnLine(other, this);
        }
        else if (other instanceof LineCollider) {
            return lineIntersection(this.start, this.end, other.start, other.end, intersection);
        }
        else if (other instanceof CircleCollider) {
            // lineInCircle() requires a reference to a vector for technical reasons, so we create a
            // throwaway and use that. We don't pass "intersection" because the value it gets set to
            // is useless in this context.
            return lineInCircle(this.start, this.end, other.position, other.radius, createVector());  
        }
        else if (other instanceof PolygonCollider) {
            return lineInPolygon(this, other);
        }
        else {
            throw new TypeError(
                `[Collider] Invalid argument to isColliding()! (Expected a PointCollider, ` +
                `LineCollider, CircleCollider, or PolygonCollider; recieved "${typeof other}")`
            );
        }
    }

    /**
     * Draws the collider; useful for debugging.
     * @param {color} color
     */
    render(color) {
        stroke(color);
        strokeWeight(6);
        line(this.start.x, this.start.y, this.end.x, this.end.y);
    }
};

/**
 * A collider for a circle.
 * @class
 */
globalThis.CircleCollider = class {
    /** @type {number} */
    x;
    /** @type {number} */
    y;
    /** @type {number} */
    radius;

    /**
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     */
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    /**
     * The radius of the circle squared. Useful for improving performance in some situations.
     * @readonly
     * @type {number}
     */
    get radiusSq() { return this.radius * this.radius; }

    /**
     * The position of the circle as a Vector.
     * @readonly
     * @type {Vector}
     */
    get position() { return createVector(this.x, this.y); }

    /**
     * @overload
     * Returns whether a `PointCollider` is inside the circle.
     * @param {PointCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether a `LineCollider` crosses or is inside of the circle.
     * @param {LineCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the circle intersects with another `CircleCollider`.
     * @param {CircleCollider} other
     * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum
     *      translation vector", which is the shortest vector that will move this circle completely
     *      out of the other one. If there is no collision, it will be set to (0, 0).
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the circle intersects with a `PolygonCollider`.
     * @param {PolygonCollider} other
     * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum
     *      translation vector", which is the shortest vector that will move the circle completely
     *      out of the polygon. If there is no collision, it will be set to (0, 0).
     * @returns {boolean}
     */
    isColliding(other, transVec=null) {
        if (other instanceof PointCollider) {
            return pointInCircle(other, this);
        }
        else if (other instanceof LineCollider) {
            // lineInCircle() requires a reference to a vector for technical reasons, so we create a
            // throwaway and use that. We don't pass transVec because the value it gets set to is
            // useless in this context.
            return lineInCircle(other.start, other.end, this.position, this.radius, createVector());
        }
        else if (other instanceof CircleCollider) {
            return circleToCircleCollide(this, other, transVec);
        }
        else if (other instanceof PolygonCollider) {
            return circleToPolygonCollide(this, other, transVec, false);
        }
        else {
            throw new TypeError(
                `[Collider] Invalid argument to isColliding()! (Expected a PointCollider, ` +
                `LineCollider, CircleCollider, or PolygonCollider; recieved "${typeof other}")`
            );
        }
    }

    /**
     * Draws the collider; useful for debugging.
     * @param {color} color
     */
    render(color) {
        noFill();
        stroke(color);
        strokeWeight(6);
        circle(this.x, this.y, this.radius * 2);
    }
};

/**
 * A collider for a convex polygon.
 * @class
 */
globalThis.PolygonCollider = class {
    /** @type {Vector} */
    #position;

    /** @type {number} */
    #angle;

    /**
     * The polygon's vertices, rotated to the current angle and offset to the current position.
     * @type {Vector[]}
     */
    #points;

    /**
     * The polygon's vertices, rotated to the current angle but not offset to the current position.
     * @type {Vector[]}
     */
    #rotatedPoints;

    /**
     * The polygon's vertices, without any rotation or offset applied.
     * @type {Vector[]}
     */
    #absolutePoints;

    /**
     * The polygon's bounding box, offset to the current position.
     * @type {BoundingBox}
     */
    #bbox;

    /**
     * The polygon's bounding box, without the current position applied.
     * @type {BoundingBox}
     */
    #rotatedBBox;

    /**
     * @param {[number, number][]} points The polygon's vertices, as an array of points. Polygons
     *      must have at least three points.
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    constructor(points, x=0, y=0) {
        this.#position = createVector();
        if (points.length < 3) {
            // normally i'd create some kind of "InvalidArgumentError" class, but that seems
            // overkill for a KA project that has to fit in 1 file
            throw new Error("[Collider] PolygonColliders must have at least three points!");
        }

        // convert vertices to vectors
        this.#points = [];
        this.#rotatedPoints = [];
        this.#absolutePoints = [];

        for (const point of points) {
            this.#points.push(createVector(point[0], point[1]));
            this.#rotatedPoints.push(createVector(point[0], point[1]));
            this.#absolutePoints.push(createVector(point[0], point[1]));
        }

        this.#rotatedBBox = getBBox(this.#rotatedPoints);
        this.#bbox = this.#rotatedBBox.copy();

        // call setPos to update everything
        this.setPos(x, y);
        this.#angle = 0;
    }

    /**
     * Returns the polygon's bounding box.
     * @returns {BoundingBox}
     */
    getBBox() { return this.#bbox.copy(); }

    /**
     * Returns an array of all the polygon's vertices.
     * @returns {Vector[]}
     */
    getPoints() {
        // do some funky stuff to deep copy the array so we don't run into issues if somebody
        // modifies anything in this array
        return this.#points.map(p => p.copy());
    };

    /**
     * Returns the polygon's current position.
     * @returns {Vector}
     */
    getPos() { return this.#position.copy(); }

    /**
     * @overload
     * Sets the polygon's current position.
     * @param {number} x
     * @param {number} y
     * 
     * @overload
     * Sets the polygon's current position.
     * @param {Vector} pos
     */
    setPos(x, y) {
        if (x instanceof p5.Vector) {
            this.#position.set(x);
        }
        else {
            this.#position.set(x, y);
        }

        // the rotated points never have the position applied to them
        for (let i = 0; i < this.#rotatedPoints.length; ++i) {
            this.#points[i].set(p5.Vector.add(this.#rotatedPoints[i], this.#position));
        }

        // also move the bounding box
        this.#bbox.x = this.#rotatedBBox.x + this.#position.x;
        this.#bbox.y = this.#rotatedBBox.y + this.#position.y;
    }

    /**
     * @overload
     * Moves the polygon by some amount.
     * @param {number} x
     * @param {number} y
     * 
     * @overload
     * Moves the polygon by some amount.
     * @param {Vector} pos
     */
    modPos(x, y) {
        if (x instanceof p5.Vector) {
            y = x.y;
            x = x.x;
        }

        this.#position.add(x, y);
        for (const p of this.#points) {
            p.x += x;
            p.y += y;
        }

        this.#bbox.x += x;
        this.#bbox.y += y;
    }

    /**
     * Returns the polygon's current angle.
     * @returns {number}
     */
    getAngle() { return this.#angle; }

    /**
     * Sets the polygon's current angle.
     * @param {number} angle
     */
    setAngle(angle) {
        this.#angle = angle;
        // this is why we have three arrays of points - it's much easier to rotate these and copy
        // them instead of trying to offset by the position
        for (let i = 0; i < this.#absolutePoints.length; ++i) {
            const p = this.#absolutePoints[i].copy();
            p.setHeading(angle + p.heading());
            this.#rotatedPoints[i] = p;
        }

        this.#rotatedBBox = getBBox(this.#rotatedPoints);
        this.#bbox = this.#rotatedBBox.copy();

        // call setPos() to rebuild the main array
        this.setPos(this.#position);
    }

    /**
     * Rotates the polygon by some amount.
     * @param {number} angle
     */
    modAngle(angle) { this.setAngle(this.#angle + angle); }

    /**
     * @overload
     * Returns whether a `PointCollider` is inside the polygon.
     * @param {PointCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether a `LineCollider` crosses or is inside of the polygon.
     * @param {LineCollider} other
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the circle intersects with another `CircleCollider`.
     * @param {CircleCollider} other
     * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum
     *      translation vector", which is the shortest vector that will move the polygon completely
     *      out of the circle. If there is no collision, it will be set to (0, 0).
     * @returns {boolean}
     * 
     * @overload
     * Returns whether the circle intersects with a `PolygonCollider`.
     * @param {PolygonCollider} other
     * @param {Vector} [transVec] If there is a collision, this will be set to the "minimum
     *      translation vector", which is the shortest vector that will move this polygon completely
     *      out of the other one. If there is no collision, it will be set to (0, 0).
     * @returns {boolean}
     */
    isColliding(other, transVec=null) {
        if (other instanceof PointCollider) {
            return pointInPolygon(other, this);
        }
        else if (other instanceof LineCollider) {
            return lineInPolygon(other, this);
        }
        else if (other instanceof CircleCollider) {
            return circleToPolygonCollide(other, this, transVec, true);
        }
        else if (other instanceof PolygonCollider) {
            return polygonToPolygonCollide(this, other, transVec);
        }
        else {
            throw new TypeError(
                `[Collider] Invalid argument to isColliding()! (Expected a PointCollider, ` +
                `LineCollider, CircleCollider, or PolygonCollider; recieved "${typeof other}")`
            );
        }
    }

    /**
     * Draws the collider; useful for debugging.
     * @param {color} color
     */
    render(color) {
        noFill();
        stroke(color);
        
        strokeWeight(3);
        rect(this.#bbox.x, this.#bbox.y, this.#bbox.w, this.#bbox.h);

        strokeWeight(6);
        beginShape();
        for (const p of this.#points) {
            vertex(p.x, p.y);
        }
        endShape(CLOSE);
    }
};
</script>
<!-- src/engine/input.js -->
<script type>
/**
 * An action-based system for managing user input.
 */
 var Input = (function() {
    /**
     * @typedef {Object} InputAction - A single input action.
     * @property {string[]} keys - Which keyboard keys and/or mouse buttons can activate the action.
     * @property {boolean} active - Whether the action is currently active (pressed).
     * @property {boolean} wasActive - Only used by press actions.
     * @property {number} bufferDuration - Only used by press actions.
     * @property {()=>void} update - Updates the action.
     */

    /**
     * Holds whether each keyboard key or mouse button is currently pressed.
     * @type {Object<string, boolean>}
     */
    const keyStates = {};

    /**
     * All currently managed actions.
     * @private
     * @type {Object<string, InputAction>}
     */
    const actions = {};

    const Input = {
        /**
         * Updates all actions. Should be called once per frame in `draw()`.
         */
        update() {
            for (const name in actions) { actions[name].update(); }
        },

        /**
         * Updates the internal state. Should be called once in `keyPressed()`.
         * @param {string} keyStr Should be `e.key`.
         */
        keyPressed(keyStr) {
            keyStates[keyStr.toLowerCase()] = true;
        },

        /**
         * Updates the internal state. Should be called once in `keyReleased()`.
         * @param {string} keyStr Should be `e.key`.
         */
        keyReleased(keyStr) {
            keyStates[keyStr.toLowerCase()] = false;
        },

        /**
         * Updates the internal state. Should be called once in `mousePressed()` (technically
         * `_mousePressed()`).
         * @param {number} button Should be `e.button`.
         */
        mousePressed(button) {
            // MouseEvent.button is a number so we have to do some conversions
            if (button === 0) {
                keyStates["left mouse"] = true;
                keyStates["left click"] = true;
            }
            else if (button === 1) {
                keyStates["middle mouse"] = true;
                keyStates["middle click"] = true;
            }
            else if (button === 2) {
                keyStates["right mouse"] = true;
                keyStates["right click"] = true;
            }
        },

        /**
         * Updates the internal state. Should be called once in `mouseReleased()` (technically
         * `_mouseReleased()`).
         * @param {number} button Should be `e.button`.
         */
        mouseReleased(button) {
            // MouseEvent.button is a number so we have to do some conversions
            if (button === 0) {
                keyStates["left mouse"] = false;
                keyStates["left click"] = false;
            }
            else if (button === 1) {
                keyStates["middle mouse"] = false;
                keyStates["middle click"] = false;
            }
            else if (button === 2) {
                keyStates["right mouse"] = false;
                keyStates["right click"] = false;
            }
        },

        /**
         * Adds an action to the manager.
         * @param {Object} args - Configuration object for the action.
         * @param {string} args.name - The name of the action.
         * @param {string[]} args.keys - Which keyboard keys and/or mouse buttons can activate the
         *      action.
         * @param {"hold"|"press"} [type="hold"] - Determines how the action activates. A hold
         *      action is active whenever any of the keys or buttons bound to it are pressed. A
         *      press action is active for a single frame when any of the keys or buttons bound to
         *      it are initially pressed.
         */
        addAction({name, keys, type="hold"}) {
            // quick check if the action already exists - this won't crash anything, but it's
            // probably not something you want to happen
            if (Object.hasOwn(actions, name)) {
                console.warn(
                    `[Input] The action "${name}" already exists, did you mean to overwrite it?`
                );
            }

            // setup common properties - both types of action have these
            /** @type {InputAction} */
            let action = {
                active: false,
                keys: keys.map((k) => k.toLowerCase())
            };

            // set update method based on type
            if (type === "hold") {
                action.update = () => {
                    // "some()" returns whether a predicate returns true for any item in an array
                    action.active = action.keys.some((k) => keyStates[k]);
                };
            }
            else {
                // add press-action-specific properties
                action.wasActive = false;
                action.bufferDuration = 0;
                action.update = () => {
                    if (action.keys.some((k) => keyStates[k])) {
                        // if there's buffer time remaining, keep the action active
                        if (action.bufferDuration > 0) {
                            // buffer duration is stored in seconds, but the p5 deltaTime variable
                            // is in milliseconds
                            action.bufferDuration -= deltaTime / 1000;
                            action.active = true;
                        }
                        // if the buffer has run out, deactivate the action
                        else if (action.wasActive) {
                            action.active = false;
                        }
                        // if this is the first frame that the key was pressed, reset the buffer and
                        // make the action active
                        else {
                            action.active = true;
                            action.wasActive = true;
                            action.bufferDuration = INPUT_BUFFER_DURATION;
                        }
                    }
                    else {
                        action.wasActive = false;
                        action.active = false;
                    }
                };
            }

            actions[name] = action;
        },

        /**
         * Returns whether an action is active.
         * @param {string} name - The name of the action.
         * @param {boolean} [clearBuffer=true] - Whether to deactivate the action if it is active.
         *      Only applies to press actions.
         * @returns {boolean}
         */
        isActive(name, clearBuffer=true) {
            const action = actions[name];
            // deactivate press actions to prevent the buffer
            // from activating them multiple times
            if (action.active && action.bufferDuration > 0 && clearBuffer) {
                action.active = false;
                action.bufferDuration = 0;
                return true;
            }
            return action.active;
        },

        /**
         * Deactivates all actions and clears any buffers.
         */
        clearBuffers() {
            for (const name in actions) {
                actions[name].active = false;
                if (actions[name].bufferDuration !== undefined) {
                    actions[name].bufferDuration = 0;
                }
            }
        }
    };
    return Input;
})();

// chuck input into global scope
globalThis.Input = Input;
</script>
<!-- src/engine/kepler.js -->
<script type>
/**
 * Kepler is NonPlayerCharacter's mildly questionable in-house game engine.
 */
// kepler needs to be defined on var for vscode to give us autocomplete, so we'll put it on
// globalThis at the end of the file
var Kepler = (function() {
    // predeclare just in case
    let Kepler;

    /**
     * Main entity list.
     * @type {EntityBase[]}
     */
    let entities = [];

    /**
     * Entities grouped into display layers - objects are passed by reference in JS, so these are
     * the same objects that are in the main list.
     * @type {Object<string, EntityBase[]>}
     */
    let displayLayers = {};

    /**
     * All active display layers.
     * @type {number[]}
     */
    let layerIndexes = [];

    /**
     * Time between the last two frames in seconds, without current time scale applied.
     * @type {number}
     */
    let deltaTimeRaw = 0;

    // camera variables - createVector() is preferred over "new PVector()" in modern p5js
    /** @type {Vector} */
    let cameraPos = createVector(width / 2, height / 2);
    /** @type {Vector} */
    let cameraTarget = cameraPos.copy();
    /** @type {number} */
    let renderX = 0;
    /** @type {number} */
    let renderY = 0;
    /** @type {number} */
    let minCameraX = -Infinity;
    /** @type {number} */
    let maxCameraX = Infinity;
    /** @type {number} */
    let minCameraY = -Infinity;
    /** @type {number} */
    let maxCameraY = Infinity;
    /** @type {[number, number, number, number]} */
    let viewportBounds = [-Infinity, -Infinity, Infinity, Infinity];

    // cameraZoom is public, but we're going to use a getter and a setter so we can auto-update the
    // viewport boundary whenever it changes
    /** @type {number} */
    let cameraZoom = 1;

    // Symbol() returns a unique object that is guaranteed to only ever be equal to itself
    const USES_SCREEN_SPACE_COORDS = Symbol("Kepler.USES_SCREEN_SPACE_COORDS");
    const USES_RAW_DELTA_TIME = Symbol("Kepler.USES_RAW_DELTA_TIME");

    /**
     * Alternate version of `dist()` that doesn't include a square root - this is useful when a
     * square root isn't necessary because square roots are slow for computers.
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @returns {number}
     */
    function distSq(x1, y1, x2, y2) {
        return pow(x2 - x1, 2) + pow(y2 - y1, 2);
    }

    /**
     * Framerate-independent version of lerp() using delta time, used for updating the camera.
     * @param {number} a 
     * @param {number} b 
     * @param {number} t 
     * @returns {number}
     */
    function damp(a, b, t) {
        return lerp(a, b, 1 - exp(-t * deltaTimeRaw * Kepler.timeScale));
    }

    /**
     * Draws an entity to the canvas.
     * @param {EntityBase} entity 
     */
    function drawEntity(entity) {
        entity.render();
        
        // only draw the hitbox if the entity has one
        if (Kepler.SHOW_HITBOXES && typeof entity.bbox === "object") {
            noFill();
            stroke(255, 0, 0);
            strokeWeight(2);
            rect(
                entity.bbox.x + 1, entity.bbox.y + 1,
                entity.bbox.w - 2, entity.bbox.h - 2
            );
        }
        
        if (Kepler.SHOW_VELOCITY_VECTORS && entity.velocity instanceof p5.Vector) {
            // draw at the center of the bounding box if it exists, otherwise draw at the position
            let startX, startY;
            if (typeof entity.bbox === "object") {
                startX = entity.bbox.x + entity.bbox.w / 2;
                startY = entity.bbox.y + entity.bbox.h / 2;
            }
            else {
                startX = entity.position.x;
                startY = entity.position.y;
            }
            
            let endX = startX + entity.velocity.x / 10;
            let endY = startY + entity.velocity.y / 10;
            
            stroke(0, 255, 0);
            strokeWeight(2);
            line(startX, startY, endX, endY);
        }
    }

    class EntityBase {
        /**
         * Which display layer the entity is on. Entities on a higher display layer will always
         * be drawn on top of entities on a lower display layer, regardless of what order they
         * were added to the engine in. Display layers can be any number, including non-integers
         * and negative numbers.
         * @type {number}
         */
        displayLayer = 0;

        /**
         * All of the entity's tags (if it has any).
         * @type {any}
         */
        tags = [];
        
        /**
         * If true, the entity will be removed from the engine when the current update ends.
         * @type {boolean}
         */
        markForRemove = false;

        /**
         * Called when the entity is added to Kepler. Does nothing by default.
         */
        onAdd() {}

        /**
         * Called when the entity is removed. Does nothing by default.
         */
        onRemove() {}

        /**
         * Draws the entity to the canvas. Does nothing by default.
         */
        render() {}

        /**
         * Updates the entity. Does nothing by default.
         * @param {number} dt The current delta time in seconds.
         */
        update(dt) {}

        /**
         * Returns whether the entity has a certain tag. This method is final and should not be
         * overriden.
         * @param {any} tag
         * @returns {boolean}
         */
        hasTag(tag) {
            return this.tags.includes(tag);
        }
    }

    Kepler = {
        /**
         * If true, renders entity hitboxes as pink rectangles. Default: false
         * @type {boolean}
         */
        SHOW_HITBOXES: false,

        /**
         * If true, renders entity velocity vectors as green lines. Default: false
         * @type {boolean}
         */
        SHOW_VELOCITY_VECTORS: false,

        /**
         * Whether to use the camera. Setting this to true without also setting a camera position or
         * target can cause strange behavior. Default: false
         * @type {boolean}
         */
        cameraEnabled: false,

        /**
         * If true, the camera is always locked to the target regardless of the camera tightness.
         * Default: false
         * @type {boolean}
         */
        cameraLocked: false,

        /**
         * Determines how quickly the camera glides toward the target (if it isn't locked). Must be
         * greater than 0. Default: 5
         * @type {number}
         */
        cameraTightness: 5,

        /**
         * "Speed of time". Must be greater than 0. Default: 1
         * @type {number}
         */
        timeScale: 1,

        /**
         * How zoomed in (or out) the canvas is. Behaves the same as the `scale()` function.
         * Default: 1
         * @type {number}
         */
        get cameraZoom() { return cameraZoom; },
        set cameraZoom(value) {
            cameraZoom = value;
            minCameraX = viewportBounds[0] + width / 2 / cameraZoom;
            maxCameraX = viewportBounds[2] - width / 2 / cameraZoom;
            minCameraY = viewportBounds[1] + height / 2 / cameraZoom;
            maxCameraY = viewportBounds[3] - height / 2 / cameraZoom;
        },

        /**
         * Entities with the `USES_SCREEN_SPACE_COORDS` tag ignore the camera position when
         * rendering (i.e., (0, 0) is always the top left corner).
         * @type {Symbol}
         */
        USES_SCREEN_SPACE_COORDS: USES_SCREEN_SPACE_COORDS,
        /**
         * Entities with the `USES_RAW_DELTA_TIME` tag always have the "true" delta time passed to
         * their `update()` methods, regardless of the current time scale.
         * @type {Symbol}
         */
        USES_RAW_DELTA_TIME: USES_RAW_DELTA_TIME,

        /**
         * Returns the current delta time (time between the last two frames) in seconds, without the
         * current time scale applied.
         * @returns {number}
         */
        deltaTimeRaw() { return deltaTimeRaw; },

        /**
         * Returns the current delta time (time between the last two frames) in seconds, with the
         * current time scale applied.
         * @returns {number}
         */
        deltaTime() { return deltaTimeRaw * Kepler.timeScale; },

        /**
         * Returns the number of entities being updated.
         * @returns {number}
         */
        numEntities() { return entities.length; },

        /**
         * Returns the current position of the camera.
         */
        getCameraPosition() { return cameraPos.copy(); },

        /**
         * @overload
         * Sets the position of the camera. The camera will immediately be snapped here; use
         * `setCameraTarget()` to move it smoothly.
         * @param {number} x
         * @param {number} y
         * 
         * @overload
         * Sets the position of the camera. The camera will immediately be snapped here; use
         * `setCameraTarget()` to move it smoothly.
         * @param {Vector} vec
         */
        setCameraPosition(x, y) {
            // overload to pass coordinates as a vector
            if (x instanceof p5.Vector) {
                y = x.y;
                x = x.x;
            }

            cameraPos.set(
                constrain(x, minCameraX, maxCameraX),
                constrain(y, minCameraY, maxCameraY)
            );
            // also set the target to prevent the camera from flying away
            cameraTarget.set(cameraPos);
        },

        /**
         * Returns the current position of the camera.
         */
        getCameraTarget() { return cameraPos.copy(); },

        /**
         * @overload
         * Sets the camera target. The camera will move smoothly toward this position; use
         * `setCameraPosition()` to immediately move it.
         * @param {number} x
         * @param {number} y
         * 
         * @overload
         * Sets the camera target. The camera will move smoothly toward this position; use
         * `setCameraPosition()` to immediately move it.
         * @param {Vector} vec
         */
        setCameraTarget(x, y) {
            // overload to pass coordinates as a vector
            if (x instanceof p5.Vector) {
                y = x.y;
                x = x.x;
            }

            cameraTarget.set(
                constrain(x, minCameraX, maxCameraX),
                constrain(y, minCameraY, maxCameraY)
            );
        },

        /**
         * Returns the viewport (the area the camera can see) in the format
         * `[left, top, right, bottom]`.
         * @returns {[number, number, number, number]}
         */
        getViewportBounds() {
            return viewportBounds.slice();
        },

        /**
         * @overload
         * Sets the viewport (the area the camera can see).
         * @param {number} left Anything with an X coordinate less than this will not be visible.
         * @param {number} top Anything with a Y coordinate less than this will not be visible.
         * @param {number} right Anything with an X coordinate greater than this will not be
         *      visible.
         * @param {number} bottom Anything with a Y coordinate greater than this will not be
         *      visible.
         * 
         * @overload
         * Sets the viewport, which determines the area that the camera can see.
         * @param {number[]} bounds - All four bounds in the format `[left, top, right, bottom]`.
         */
        setViewportBounds(left, top, right, bottom) {
            // overload to pass all 4 bounds as an array
            if (Array.isArray(left)) {
                viewportBounds = left.slice();
            }
            else {
                viewportBounds = [left, top, right, bottom];
            }
            minCameraX = viewportBounds[0] + width / 2 / cameraZoom;
            maxCameraX = viewportBounds[2] - width / 2 / cameraZoom;
            minCameraY = viewportBounds[1] + height / 2 / cameraZoom;
            maxCameraY = viewportBounds[3] - height / 2 / cameraZoom;
        },

        /**
         * Adds an entity to the engine, then returns a reference to it (this is more useful than it
         * probably sounds).
         * @template {EntityBase} T
         * @param {T} entity
         * @param {boolean} [allowSetup=true] Whether to call the entity's `onAdd()` method.
         * @returns {T}
         */
        addEntity(entity, allowSetup=true) {
            if (allowSetup) {
                entity.onAdd(); // may or may not do something
            }

            entities.push(entity);

            // if a display layer already exists for the entity, just add it to that layer
            if (layerIndexes.includes(entity.displayLayer)) {
                displayLayers[entity.displayLayer].push(entity);
            }
            // otherwise, create a new display layer
            else {
                displayLayers[entity.displayLayer] = [entity];
                layerIndexes.push(entity.displayLayer);
                // make sure layers actually stay in order
                // "(a, b) => a - b" is es6 shorthand for "function(a, b) { return a - b; }"
                layerIndexes.sort((a, b) => a - b);
            }

            // return a reference to the entity so we can store it somewhere if we want
            return entity;
        },

        /**
         * Updates delta time, without updating any entities. Useful when the game is paused.
         */
        updateDtOnly() {
            // p5js delta time is in milliseconds
            deltaTimeRaw = deltaTime / 1000;
        },

        /**
         * Updates delta time and all entities. Should be called once per frame in draw().
         */
        update() {
            // p5js delta time is in milliseconds
            deltaTimeRaw = deltaTime / 1000;

            for (const entity of entities) {
                if (entity.hasTag(USES_RAW_DELTA_TIME)) {
                    entity.update(deltaTimeRaw);
                }
                else {
                    entity.update(deltaTimeRaw * Kepler.timeScale);
                }
            }

            // remove deleted entities
            Kepler.removeIf((e) => e.markForRemove);

            // update camera position
            if (Kepler.cameraEnabled) {
                cameraPos.x = constrain(cameraPos.x, minCameraX, maxCameraX);
                cameraPos.y = constrain(cameraPos.y, minCameraY, maxCameraY);
                cameraTarget.x = constrain(cameraTarget.x, minCameraX, maxCameraX);
                cameraTarget.y = constrain(cameraTarget.y, minCameraY, maxCameraY);

                let delta = distSq(cameraPos.x, cameraPos.y, cameraTarget.x, cameraTarget.y);

                if (Kepler.cameraLocked || delta < pow(0 / cameraZoom, 2)) {
                    cameraPos.set(cameraTarget);
                }
                else {
                    cameraPos.set(
                        damp(cameraPos.x, cameraTarget.x, Kepler.cameraTightness),
                        damp(cameraPos.y, cameraTarget.y, Kepler.cameraTightness)
                    );
                }
            }
        },

        /**
         * Draws all entities to the canvas.
         */
        render() {
            if (Kepler.cameraEnabled) {
                renderX = -floor(cameraPos.x - width / 2 / cameraZoom);
                renderY = -floor(cameraPos.y - height / 2 / cameraZoom);
        
                // like pushMatrix(), but also affects style commands (fill, stroke, etc.)
                push();
                scale(cameraZoom);
                translate(renderX, renderY);
                for (const i of layerIndexes) {
                    for (const entity of displayLayers[i]) {
                        if (entity.hasTag(USES_SCREEN_SPACE_COORDS)) {
                            translate(-renderX, -renderY);
                            scale(1 / cameraZoom);
        
                            push();
                            drawEntity(entity);
                            pop();
        
                            scale(cameraZoom);
                            translate(renderX, renderY);
                        }
                        else {
                            push();
                            drawEntity(entity);
                            pop();
                        }
                    }
                }
                pop();
            }
            else {
                for (const i of layerIndexes) {
                    for (const entity of displayLayers[i]) {
                        push();
                        drawEntity(entity);
                        pop();
                    }
                }
            }
        },

        /**
         * Removes all entities.
         * @param {boolean} [silent=true] If true, entities' `onRemove()` methods are not called.
         */
        removeAll(silent=true) {
            if (!silent) {
                for (const entity of entities) {
                    entity.onRemove();
                }
            }

            entities = [];
            displayLayers = {};
            layerIndexes = [];
        },

        /**
         * Removes all entities that a predicate function returns true for.
         * @param {(EntityBase)=>boolean} predicate
         * @param {boolean} [silent=false] - If true, entities' `onRemove()` methods are not called.
         */
        removeIf(predicate, silent=false) {
            // filter() removes entities that a predicate returns *false* for
            let filterFunction = (e) => !predicate(e);

            if (silent) {
                entities = entities.filter(filterFunction);
            }
            else {
                let filtered = [];
                for (const entity of entities) {
                    if (filterFunction(entity)) {
                        filtered.push(entity);
                    }
                    else {
                        entity.onRemove();
                    }
                }
                entities = filtered;
            }

            // also remove entities from display layers
            for (const i of layerIndexes) {
                displayLayers[i] = displayLayers[i].filter(filterFunction);
            }
        },

        /**
         * Removes all entities that have a certain tag.
         * @param {any} tag
         * @param {boolean} [silent=false] - If true, entities' `onRemove()` methods are not called.
         */
        removeTagged(tag, silent=false) {
            Kepler.removeIf((e) => e.hasTag(tag), silent);
        },

        /**
         * Returns an array containing references to all entities.
         * @returns {EntityBase[]}
         */
        getAll() {
            // shallow copy the array to prevent issues if it gets modified by something
            return entities.slice();
        },

        /**
         * Returns an array containing references to all entities that a predicate function returns
         * true for.
         * @param {(EntityBase)=>boolean} predicate
         * @returns {EntityBase[]}
         */
        getIf(predicate) {
            return entities.filter(predicate);
        },

        /**
         * Returns an array containing references to all entities with a certain tag
         * @param {any} tag
         * @returns {EntityBase[]}
         */
        getTagged(tag) {
            return Kepler.getIf((e) => e.hasTag(tag));
        },

        /**
         * @overload
         * Converts a position in screen space (relative to the top left corner of the canvas) to a
         * position in world space (relative to the camera).
         * @param {number} x
         * @param {number} y
         * @returns {Vector}
         * 
         * @overload
         * Converts a position in screen space (relative to the top left corner of the canvas) to a
         * position in world space (relative to the camera).
         * @public
         * @param {Vector} vec
         * @returns {Vector}
         */
        screenPosToWorldPos(x, y) {
            // overload to pass coordinates as a vector
            if (x instanceof p5.Vector) {
                y = x.y;
                x = x.y;
            }

            return createVector((x / cameraZoom) - renderX, (y / cameraZoom) - renderY);
        },

        /**
         * @overload
         * Converts a position in world space (relative to the camera) to a position in screen space
         * (relative to the top left corner of the canvas).
         * @param {number} x
         * @param {number} y
         * @returns {Vector}
         * 
         * @overload
         * Converts a position in world space (relative to the camera) to a position in screen space
         * (relative to the top left corner of the canvas).
         * @param {Vector} vec
         * @returns {Vector}
         */
        worldPosToScreenPos(x, y) {
            // overload to pass coordinates as a vector
            if (x instanceof p5.Vector) {
                y = x.y;
                x = x.x;
            }

            return createVector((x * cameraZoom) + renderX, (y * cameraZoom) + renderY);
        },

        /**
        * Base class that all entities should extend.
        * @class
        */
        EntityBase: EntityBase
    };

    return Kepler;
})();
// chuck Kepler into global scope
globalThis.Kepler = Kepler;
</script>
<!-- src/entities/misc.js -->
<script type>
// this file is for entities that don't fit into any other category
/**
 * A grid in the background to show movement.
 * @class
 * @extends {Kepler.EntityBase}
 */
// this is so cursed i love it so much
globalThis.BackgroundGrid = class extends Kepler.EntityBase {
    /** @type {number} */
    #width;
    /** @type {number} */
    #height;

    displayLayer = -100;

    /**
     * @param {number} bgWidth Width in squares. Squares are 300 pixels on a side.
     * @param {number} bgHeight Height in squares.
     */
    constructor(bgWidth, bgHeight) {
        super(); // this does literally nothing but is still required because javascript

        this.#width = bgWidth;
        this.#height = bgHeight;
    }

    render() {
        let colorToggle = true;

        noStroke();
        for (let x = 0; x < this.#width; ++x) {
            for (let y = 0; y < this.#height; ++y) {
                fill(colorToggle ? "#b0b0b0" : "#ffffff");

                rect(x * 300, y * 300, 300, 300);
                colorToggle = !colorToggle;
            }
            if (this.#height % 2 === 0) {
                colorToggle = !colorToggle;
            }
        }
    }
};

/**
 * A bullet fired from a projectile weapon.
 * @class
 * @extends {Kepler.EntityBase}
 */
globalThis.Bullet = class extends Kepler.EntityBase {
    /** @type {Vector} */
    position;
    /** @type {Vector} */
    startPos;
    /** @type {Vector} */
    velocity;
    /** @type {number} */
    maxRange;
    /** @type {CircleCollider} */
    collider;
    /** @type {number} */
    size;

    displayLayer =  10;

    /**
     * @param {Vector} position
     * @param {Vector} velocity
     * @param {number} maxRange
     * @param {number} size Radius of the bullet's hitbox.
     */
    constructor(position, velocity, maxRange, size) {
        super(); // this does literally nothing but is still required because javascript

        this.position = position.copy();
        this.startPos = position.copy(); // used for range checks
        this.velocity = velocity.copy();
        this.maxRange = maxRange;
        this.size = size;
        this.collider = new CircleCollider(position.x, position.y, size);
    }

    update(dt) {
        // apply delta time and move
        this.position.add(p5.Vector.mult(this.velocity, dt))
        this.collider.x = this.position.x;
        this.collider.y = this.position.y;

        // make sure we're not beyond the weapon's range
        if (this.position.dist(this.startPos) > this.maxRange) {
            // delete ourselves and sip the rest of the update
            this.markForRemove = true;
            return;
        }

        // check for collisions
        const entities = Kepler.getTagged("player weapon target");
        for (const entity of entities) {
            if (this.collider.isColliding(entity.collider)) {
                entity.onBulletHit();
                // delete ourselves and skip the rest of the update
                this.markForRemove = true;
                return;
            }
        }
    }

    render() {
        noStroke();
        fill("#000000");
        circle(this.position.x, this.position.y, this.size * 2);
    }
}

/**
 * Visual tracer for hitscan weapons.
 * @class
 * @extends {Kepler.EntityBase}
 */
globalThis.HitscanTracer = class extends Kepler.EntityBase {
    /** @type {Vector} */
    start;
    /** @type {Vector} */
    end;
    /**
     * How long until the tracer is removed, in seconds. Also determines opacity.
     * @type {number}
     */
    maxLifetime = 0.15;
    /** @type {number} */
    lifetime;

    displayLayer = 10;

    /**
     * @param {Vector} start
     * @param {Vector} end
     */
    constructor(start, end) {
        super();
        this.start = start.copy();
        this.end = end.copy();
        this.lifetime = this.maxLifetime;
    }

    update(dt) {
        this.lifetime -= dt;
        if (this.lifetime < 0) {
            this.markForRemove = true;
        }
    }

    render() {
        stroke(247, 153, 38, map(this.lifetime, 0, this.maxLifetime, 0, 255));
        strokeWeight(6);
        line(this.start.x, this.start.y, this.end.x, this.end.y);
    }
}

/**
 * A static target, mainly for debugging.
 * @class
 * @extends {Kepler.EntityBase}
 */
globalThis.StaticTarget = class extends Kepler.EntityBase {
    /** @type {number} */
    x;
    /** @type {number} */
    y;
    /** @type {CircleCollider} */
    collider;
    
    displayLayer = -5;
    tags = ["player weapon target"];

    /**
     * @param {number} x
     * @param {number} y
     */
    constructor(x, y) {
        super();
        this.x = x;
        this.y = y;
        this.collider = new CircleCollider(x, y, 50);
    }

    render() {
        const c1 = "#fb3232"
        const c2 = "#ffffff";
        let c = c1;

        noStroke();
        for (let d = 100; d > 0; d -= 20) {
            fill(c);
            circle(this.x, this.y, d);
            c = (c === c1 ? c2 : c1);
        }
    }

    onBulletHit() {
        console.log("static target hit");
    }
}
</script>
<!-- src/entities/player.js -->
<script type>
// the player is important enough to get its own file
/**
 * The player.
 * @class
 */
globalThis.Player = class extends Kepler.EntityBase {
    /** @type {Sprite} */
    #sprite;

    /** @type {Vector} */
    position;
    /** @type {Vector} */
    velocity;
    /** @type {number} */
    facingAngle;

    /**
     * The currently equipped weapon.
     * @type {WeaponBase}
     */
    currentWeapon;

    /**
     * @param {number} x
     * @param {number} y
     */
    constructor(x, y) {
        super(); // this does literally nothing but is still required because javascript

        // grab a reference to our sprite so we don't have to get one every time we render
        this.#sprite = sprites.player;

        // p5js really wants you to use createVector() over "new p5.Vector()"
        this.position = createVector(x, y);
        // calling createVector() with no parameters returns a zero vector
        this.velocity = createVector();

        this.facingAngle = 0;

        // this is currently hard-coded for testing but it will be changed later
        this.currentWeapon = weapons.pistols[0];
    }

    update(dt) {
        // aim at the mouse
        // find the position of the mouse relative to the player
        this.facingAngle = Kepler.screenPosToWorldPos(mouseX, mouseY)
                                 .sub(this.position)
                                 .heading();

        // update weapon
        if (Input.isActive("shoot semi")) {
            this.currentWeapon.semiAutoFire();
        }
        if (Input.isActive("shoot auto")) {
            this.currentWeapon.fullAutoFire();
        }
        // spawn bullets slightly in front of the player
        this.currentWeapon.constantUpdate(
            dt, this.facingAngle,
            p5.Vector.add(p5.Vector.fromAngle(radians(this.facingAngle), 40), this.position)
        );

        // get movement input - doing it this way means that opposite keys cancel each other out
        let moveDir = createVector();
        if (Input.isActive("move left"))  { --moveDir.x; }
        if (Input.isActive("move right")) { ++moveDir.x; }
        if (Input.isActive("move up"))    { --moveDir.y; }
        if (Input.isActive("move down"))  { ++moveDir.y; }

        // normalize so diagonal movement isn't faster
        moveDir.normalize();

        // update velocity
        this.velocity.set(moveDir.mult(400));

        // apply delta time and move
        this.position.add(p5.Vector.mult(this.velocity, dt));

        // update the camera
        Kepler.setCameraTarget(this.position);
    }

    render() {
        this.#sprite.render(this.position, this.facingAngle);
    }

    onAdd() {
        // snap the camera to our position at the start
        Kepler.setCameraPosition(this.position);
    }
}
</script>
<!-- src/weapons/standard-weapons.js -->
<script type>
/**
 * This file is for the classes that are shared by multiple weapons.
 */

/**
 * Abstract base class that all weapon classes should extend.
 * @class
 */
 globalThis.WeaponBase = class {
    /** @type {"semi"|"full"} */
    fireMode;

    /** @type {number} */
    shotsPerBurst;

    /**
     * Time between each shot in a burst, in seconds.
     * @type {number}
     */
    shotDelay;

    /**
     * Time between each burst in seconds.
     * @type {number}
     */
    burstDelay;

    /**
     * How many bullets or hitscans are fired per shot. Use this for shotguns.
     * @type {number}
     */
    bulletsPerShot;

    /**
     * Minimum spread angle in degrees.
     * @type {number}
     */
    minSpread;

    /**
     * Maximum spread angle in degrees.
     * @type {number}
     */
    maxSpread;

    /**
     * How much the spread angle increases by when a shot is fired, in degrees.
     * @type {number}
     */
    spreadBloom;

    /**
     * How quickly the spread angle decreases when not firing, in degrees per second.
     * @type {number}
     */
    spreadRecovery;

    /**
     * Whether the weapon is currently firing a burst.
     * @type {boolean}
     */
    firingBurst;

    /**
     * Remaining delay between bursts.
     * @type {number}
     */
    burstTimer;

    /**
     * Remaining delay between shots in a burst.
     * @type {number}
     */
    shotTimer;

    /**
     * How many shots are left in the current burst.
     * @type {number}
     */
    burstShotsRemaining;

    /**
     * Current spread angle.
     * @type {number}
     */
    spreadAngle;

    /**
     * @param {Object} args
     * @param {"semi"|"full"} args.fireMode Semi-auto: Fires one shot per trigger pull. Full-auto:
     *      continuously fires as long as the trigger is held down.
     * @param {number} args.fireRate How quickly bursts are fired, in rounds per minute.
     * @param {number} args.burstRate How quickly shots are fired within a burst, in rounds per
     *      minute.
     * @param {number} args.shotsPerBurst How many shots are fired per burst. Use this for
     *      burst-fire weapons.
     * @param {number} args.bulletsPerShot How many bullets or hitscans are fired per shot. Use this
     *      for shotguns.
     * @param {number} args.minSpread Minimum spread angle in degrees.
     * @param {number} args.maxSpread Maximum spread angle in degrees.
     * @param {number} args.spreadBloom How much the spread angle increases by when a shot is fired,
     *      in degrees.
     * @param {number} args.spreadRecovery How quickly the spread angle decreases when not firing,
     *      in degrees per second.
     */
    constructor({ fireMode, fireRate, burstRate, shotsPerBurst, bulletsPerShot, minSpread,
                  maxSpread, spreadBloom, spreadRecovery }) {
        this.fireMode = fireMode;
        this.shotsPerBurst = shotsPerBurst;
        this.bulletsPerShot = bulletsPerShot;
        this.minSpread = minSpread;
        this.maxSpread = maxSpread;
        this.spreadBloom = spreadBloom;
        this.spreadRecovery = spreadRecovery;
        
        // rounds per minute is easier to visualize, but seconds per round makes the math easier
        this.burstDelay = 1 / (fireRate / 60);
        this.shotDelay = 1 / (burstRate / 60);

        // setup internal stuff
        this.firingBurst = false;
        this.burstTimer = 0;
        this.shotTimer = 0;
        this.burstShotsRemaining = 0;
        this.spreadAngle = minSpread;
    }

    /**
     * Called once when the shoot button is initially pressed.
     */
    semiAutoFire() {
        // never do anything if this is a full-auto weapon
        if (this.fireMode !== "semi") { return; }

        // make sure we're not already firing, and we're not waiting for a delay to timeout
        if (!this.firingBurst && this.burstTimer <= 0) {
            this.firingBurst = true;
            this.burstShotsRemaining = this.shotsPerBurst;

            // ensures we fire on the next update
            this.shotTimer = 0;
        }
    }

    /**
     * Called once per frame while the shoot button is held down.
     */
    fullAutoFire() {
        // never do anything if this is a semi-auto weapon
        if (this.fireMode !== "full") { return; }

        // make sure we're not already firing, and we're not waiting for a delay to timeout
        if (!this.firingBurst && this.burstTimer <= 0) {
            this.firingBurst = true;
            this.burstShotsRemaining = this.shotsPerBurst;

            // ensures we fire on the next update
            this.shotTimer = 0;
        }
    }

    /**
     * Called once per frame, every frame.
     * @param {number} dt The time between the last two updates, in seconds.
     * @param {number} aimAngle What angle (approximately) to shoot at.
     * @param {Vector} origin What position to shoot from.
     */
    constantUpdate(dt, aimAngle, origin) {
        let applySpreadRecovery = true;

        if (this.firingBurst) {
            // fire bullets if we can
            if (this.shotTimer <= 0) {
                // find which angles to fire bullets at
                let minAngle = aimAngle - this.spreadAngle / 2;
                let maxAngle = aimAngle + this.spreadAngle / 2;

                for (let i = 0; i < this.bulletsPerShot; ++i) {
                    this.fire(random(minAngle, maxAngle), origin);
                }
                // only apply spread bloom once
                this.spreadAngle += this.spreadBloom;
                applySpreadRecovery = false;

                // continue or end the burst
                --this.burstShotsRemaining;
                if (this.burstShotsRemaining > 0) {
                    this.shotTimer = this.shotDelay;
                }
                else {
                    this.burstTimer = this.burstDelay;
                    this.firingBurst = false;
                }
            }
            // otherwise, update the delay
            else {
                this.shotTimer -= dt;
            }
        }
        else {
            this.burstTimer -= dt;
        }

        if (applySpreadRecovery) {
            this.spreadAngle -= this.spreadRecovery;
        }

        // always apply limits
        this.spreadAngle = constrain(this.spreadAngle, this.minSpread, this.maxSpread);
    }

    /**
     * Called whenever a bullet or raycast should be fired.
     * @param {number} angle What angle to fire at.
     * @param {Vector} origin What angle to fire from.
     */
    fire(angle, origin) {}
};

/**
 * A weapon that fires projectiles.
 * @class
 * @extends {WeaponBase}
 */
globalThis.ProjectileWeapon = class extends WeaponBase {
    /**
     * Bullet speed in units per second.
     * @type {number}
     */
    shotVelocity;
    /**
     * Maximum range of bullets in units.
     * @type {number}
     */
    maxRange;
    /**
     * Radius of each bullet's collider in units.
     * @type {number}
     */
    bulletSize;

    /**
     * @param {Object} args
     * @param {"semi"|"full"} args.fireMode Semi-auto: Fires one shot per trigger pull. Full-auto:
     *      continuously fires as long as the trigger is held down.
     * @param {number} args.fireRate How quickly bursts are fired, in rounds per minute.
     * @param {number} args.burstRate How quickly shots are fired within a burst, in rounds per
     *      minute.
     * @param {number} args.shotsPerBurst How many shots are fired per burst. Use this for
     *      burst-fire weapons.
     * @param {number} args.bulletsPerShot How many bullets or hitscans are fired per shot. Use this
     *      for shotguns.
     * @param {number} args.minSpread Minimum spread angle in degrees.
     * @param {number} args.maxSpread Maximum spread angle in degrees.
     * @param {number} args.spreadBloom How much the spread angle increases by when a shot is fired,
     *      in degrees.
     * @param {number} args.spreadRecovery How quickly the spread angle decreases when not firing,
     *      in degrees per second.
     * @param {number} args.shotVelocity Bullet speed in units per second.
     * @param {number} args.maxRange Maximum range of bullets in units.
     * @param {number} args.bulletSize Radius of each bullet's collider in units.
     */
    constructor(args) {
        // set up all the stuff in the base class
        super(args);

        this.shotVelocity = args.shotVelocity;
        this.maxRange = args.maxRange;
        this.bulletSize = args.bulletSize;
    }

    fire(angle, origin) {
        Kepler.addEntity(new Bullet(origin,
            // for some reason, fromAngle ignores angleMode
            p5.Vector.fromAngle(radians(angle), this.shotVelocity),
            this.maxRange, this.bulletSize
        ))
    }
};

/**
 * A weapon that instantly hits targets instead of firing projectiles.
 * @class
 * @extends {WeaponBase}
 */
globalThis.HitscanWeapon = class extends WeaponBase {
    /**
     * Maximum range of bullets in units.
     * @type {number}
     */
    maxRange;

    /**
     * @param {Object} args
     * @param {"semi"|"full"} args.fireMode Semi-auto: Fires one shot per trigger pull. Full-auto:
     *      continuously fires as long as the trigger is held down.
     * @param {number} args.fireRate How quickly bursts are fired, in rounds per minute.
     * @param {number} args.burstRate How quickly shots are fired within a burst, in rounds per
     *      minute.
     * @param {number} args.shotsPerBurst How many shots are fired per burst. Use this for
     *      burst-fire weapons.
     * @param {number} args.bulletsPerShot How many bullets or hitscans are fired per shot. Use this
     *      for shotguns.
     * @param {number} args.minSpread Minimum spread angle in degrees.
     * @param {number} args.maxSpread Maximum spread angle in degrees.
     * @param {number} args.spreadBloom How much the spread angle increases by when a shot is fired,
     *      in degrees.
     * @param {number} args.spreadRecovery How quickly the spread angle decreases when not firing,
     * @param {number} args.maxRange Maximum range of shots in units.
     */
    constructor(args) {
        // set up all the stuff in the base class
        super(args);

        this.maxRange = args.maxRange;
    }

    fire(angle, origin) {
        const rayEnd = p5.Vector.fromAngle(radians(angle), this.maxRange)
                                .add(origin);
        // add a visual tracer
        Kepler.addEntity(new HitscanTracer(origin, rayEnd));
    }
};
</script>
<!-- src/main.js -->
<script type>
// all the global variables that don't fit into another file
/**
 * Class instances for every weapon.
 * @type {Object<string, WeaponBase[]>}
 */
 globalThis.weapons = {};

/**
 * Class instances for all sprites.
 * @type {Object<string, Sprite>}
 */
globalThis.sprites = {};

/**
 * Whether async loading is complete. If this is false, lots of things are probably undefined!
 * @type {boolean}
 */
let asyncLoadingComplete = false;

/**
 * Async function for loading everything.
 */
async function asyncPreload() {
    // promises are complicated and even i don't fully understand how to use them, but the important
    // part is that the code inside them runs at the same time as everything else (kinda)
    console.log("Started async loading...");
    // for performance timing
    const asyncLoadStart = window.performance.now();

    // start loading sprites
    const loadSprites = new Promise((resolve) => {
        // for performance timing
        const loadStart = window.performance.now();

        for (const [spriteName, spriteData] of Object.entries(SPRITE_DATA)) {
            sprites[spriteName] = new Sprite(spriteData);
        }

        console.log(`Async loaded sprites in ${window.performance.now() - loadStart}ms`);

        // end the promise
        resolve();
    });

    // start loading weapons - in practice, this is fast enough that we could do it without a
    // promise and not have any issues, but we're already using a promise for the sprites (which
    // *are* slow enough to potentially be an issue) and using one for weapons probably makes me
    // look smarter or something
    const loadWeapons = new Promise((resolve) => {
        // for performance timing
        const loadStart = window.performance.now();

        for (const [category, configList] of Object.entries(WEAPONS)) {
            let instances = [];
            for (const weaponConfig of configList) {
                switch (weaponConfig.weaponType) {
                    case "projectile":
                        instances.push(new ProjectileWeapon(weaponConfig));
                        break;
                    case "hitscan":
                        instances.push(new HitscanWeapon(weaponConfig));
                        break;
                }
            }
            weapons[category] = instances;
        }

        console.log(`Async loaded weapons in ${window.performance.now() - loadStart}ms`);

        // end the promise
        resolve();
    });

    // start generating inputs
    const loadInputs = new Promise((resolve) => {
        // for performance timing
        const loadStart = window.performance.now();

        for (const [bindName, bindKeys] of Object.entries(KEYBINDS)) {
            // having two keybinds for shooting makes some things easier
            if (bindName === "shoot") {
                Input.addAction({
                    name: "shoot semi",
                    keys: bindKeys,
                    type: "press"
                });
                Input.addAction({
                    name: "shoot auto",
                    keys: bindKeys,
                    type: "hold"
                });
            }
            else {
                Input.addAction({
                    name: bindName,
                    keys: bindKeys
                });
            }
        }

        console.log(`Async loaded inputs in ${window.performance.now() - loadStart}ms`);

        // end the promise
        resolve();
    });

    // now that we've spawned both promises, we wait for them to both finish - this will stop the
    // code in this function from running, but the code outside of it will still keep going
    await loadSprites;
    await loadWeapons;
    await loadInputs;

    // set a flag to show that everything is loaded and safe to use
    asyncLoadingComplete = true;

    console.log(`Finished async loading in ${window.performance.now() - asyncLoadStart}ms`);
}

/**
 * Runs once when the program starts.
 */
function setup() {
    // weird funky html stuff - createCanvas() returns a reference to the canvas, but its a
    // p5.Element instance and we need an HTMLElement instance so we can add event listeners to it
    const c = createCanvas(600, 600);
    const canvas = document.getElementById(c.id());

    // the reason we do this is because there's a bug with p5js that causes mouseButton to be
    // incorrect if you hold both buttons at the same time
    canvas.addEventListener("mousedown", _mousePressed);
    canvas.addEventListener("mouseup", _mouseReleased);

    // disable the right-click menu
    canvas.addEventListener("contextmenu", (e) => { e.preventDefault() });

    // unlike on KA, the default angle mode in p5js is degrees
    angleMode(DEGREES);

    // start loading everything - right now this has no effect because we're launching straight into
    // gameplay, but eventually we'll be able to immediately start drawing logos and/or menus while
    // everything else loads
    asyncPreload();

    // debug toggles
    Kepler.SHOW_HITBOXES = false;

    // set up some camera stuff
    Kepler.cameraEnabled = true;
    Kepler.setViewportBounds(0, 0, 1200, 1200);

    // add entities - eventually this will be done procedurally, but for now i'm just hard-coding it
    Kepler.addEntity(new BackgroundGrid(4, 4));
    Kepler.addEntity(new Player(250, 100));

    Kepler.addEntity(new StaticTarget(300, 250));
    Kepler.addEntity(new StaticTarget(350, 450));
    Kepler.addEntity(new StaticTarget(400, 650)); 

    Kepler.cameraZoom = 0.75;
}

/**
 * Runs once per frame, just like in the original PJS.
 */
function draw() {
    // display a loading screen if async loading still isn't finished for some reason
    if (!asyncLoadingComplete) {
        // eventually we'll need to put an actual graphic here, but for now i'm just throwing up a
        // black screen because people probably won't ever see this
        background("#000000");
        // skip the rest of draw()
        return;
    }

    Input.update();
    Kepler.update();

    background("#ffffff");
    Kepler.render();
}

/**
 * Called once when a key is initially pressed.
 * @param {KeyboardEvent} e
 */
function keyPressed(e) {
    // we don't use the p5js-specific "key" variable because it doesn't update for things like
    // shift or the arrow keys
    Input.keyPressed(e.key);
}

/**
 * Called once when a key is initially pressed.
 * @param {KeyboardEvent} e
 */
function keyReleased(e) {
    Input.keyReleased(e.key);
}

// we put underscores here because we don't want them to become the p5 functions - we're going to
// add them ourselves to avoid a p5js-specific bug
/**
 * Called once when the mouse is initially pressed.
 * @param {MouseEvent} e
 */
function _mousePressed(e) {
    Input.mousePressed(e.button);
}

/**
 * Called once when the mouse is initially released.
 * @param {MouseEvent} e
 */
function _mouseReleased(e) {
    Input.mouseReleased(e.button);
}
</script>

<!-- Project code ends here. -->

</head>
<!-- Do not touch anything below this line!! -->
<body>
    <main>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script type>
        var r = 600; 
        var s = document.documentElement.clientWidth;
        console.log(window.parent,window.parent.parent)
        window.parent.parent.html2canvas = e => {
            try {
                html2canvas(document.body, {
                    width:   s,
                    height:  s,
                    useCORS: true,
                    onclone: e => e.getAnimations().forEach(a=>{
                        try {
                            a.finish();
                        } catch{}
                    })
                }).then(e => {
                    var c = document.createElement("canvas");
                    c.width  = r;
                    c.height = r;
                    c.getContext('2d').drawImage(e, 0, 0, e.width, e.height, 0, 0, r, r);
                    console.log(c.toDataURL())
                    window.top.postMessage(c.toDataURL(), "*");
                }).catch(e => { 
                    alert("Thumbnail Script Error: " + e);  
                });
            } catch {
                window.top.postMessage(document.createElement("canvas").toDataURL(), "*"); 
            }
        }; 
    </script> 
    <!--This must be the last script in the document I think.
    Basically, it replaces this html document with an iframe containg this same document. Deals with KA freezing the window object and simlar stuff.--> 
<script type> 
    // console.log(Date.now()-sessionStorage.getItem("lastload"));
    if(!sessionStorage.getItem("lastload") || Date.now() - sessionStorage.getItem("lastload") > 1500){
        var fullHTML = `<!DOCTYPE html>${document.documentElement.outerHTML}`;
        document.body.innerHTML=`<iframe src="${URL.createObjectURL(new Blob([fullHTML],{type:"text/html"}))}"style="width:100vw;height:100vh;position:absolute;top:0px;left:0px;border:none"></iframe>`;
        sessionStorage.setItem("lastload",Date.now());
    }
    </script>
    <script>/*Extra Script tag for reload button.*/</script>
    
</body>
</html>